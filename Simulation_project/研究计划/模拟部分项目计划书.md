# **项目模拟部分架构与需求文档**

**版本:** 1.0  
**日期:** 2025年9月25日  
**目标:** 指导“农村女性就业市场动态演化”项目模拟部分的模块化开发。

## 1. 概述

本项目已完成数据分析与主体属性的分布建模阶段。为确保后续大规模模拟的效率、准确性与可维护性，特制定本架构与需求文档。本文档将模拟系统分解为五个核心模块和一个全局配置中心，定义了每个模块的功能、接口与依赖关系，旨在为开发团队提供清晰的实现指南。

## 2. 总体架构

整个模拟系统采用模块化设计，由一个中心化的**`CONFIG`模块**和五个功能独立的**代码模块**构成。所有代码模块均为无状态的，其行为完全由外部配置文件和输入数据决定，以实现最大化的灵活性和可复现性。

**架构图:**
[config.yaml] <--- (全局参数配置中心)
|
|-----> [模块1: PopulationGenerator] ---> (输出: Agent池)
|           ^
|           | (依赖: 清洗后的调研数据)
|
|-----> [模块2: MatchingEngine] ---> (输出: 模拟匹配数据集)
|           ^
|           | (依赖: Agent池)
|
|-----> [模块3: MatchFunctionEstimator] ---> (输出: 匹配函数λ的参数)
|           ^
|           | (依赖: 模拟匹配数据集)
|
|-----> [模块4: MFGSimulator] ---> (输出: 均衡状态结果)
|           ^
|           | (依赖: Agent池, 匹配函数λ的参数)
|
|-----> [模块5: ExperimentController] ---> (输出: 校准/政策分析报告)
^
| (调用并管理MFGSimulator)


## 3. 核心模块：`CONFIG` (全局配置文件)

为了避免硬编码，所有参数都应在外部`config.yaml`文件中定义。主程序启动时加载此文件，并将配置信息传递给各个模块。

**建议的 `config.yaml` 结构:**
```yaml
# ====================================================
#  项目全局配置文件 (config.yaml)
# ====================================================

project_settings:
  project_name: "Rural_Female_Labor_Market_MFG"
  version: "1.0"
  author: "RUC_Economics_Team"

io_paths:
  # 输入路径
  cleaned_data_csv: "./cleaned_data.csv"
  marginal_distributions_json: "./results/marginal_params.json" # distribution_inference.py的输出
  
  # 输出路径
  results_output_dir: "./results/"
  log_file_path: "./logs/simulation.log"

population_generator_settings:
  n_labor_agents: 10000        # 生成的劳动力主体数量
  n_enterprise_agents: 8000    # 生成的企业主体数量 (用于匹配引擎)
  core_variables: ['每周工作时长', '工作能力评分', '数字素养评分', '每月期望收入']
  control_variables: ['年龄', '累计工作年限', '家务劳动时间', '闲暇时间']
  copula_settings:
    candidate_families: ['gaussian', 't'] # 要测试的Copula族
    selection_criterion: 'AIC'            # 模型选择标准

matching_engine_settings:
  market_tightness_scenarios: [0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3] # 用于估计匹配函数的Theta值列表
  preference_function_coeffs:
    jobseeker: # 求职者偏好函数系数 (γ)
      gamma_0: 1.0
      gamma_T: -0.1
      gamma_S: -0.5
      gamma_D: -0.5
      gamma_W: 0.2
    employer: # 企业偏好函数系数 (β)
      beta_0: 1.0
      beta_T: 0.2
      beta_S: 0.5
      beta_D: 0.3
      beta_W: -0.4

mfg_simulator_settings:
  discretization: # 状态空间离散化设置
    n_grid_points_T: 10
    n_grid_points_S: 10
    n_grid_points_D: 10
    n_grid_points_W: 10
  bellman_equation: # 贝尔曼方程参数
    discount_factor_rho: 0.95
    effort_cost_kappa: 1.5
  utility_functions: # 效用函数参数
    employment_omega_coeffs: [0.1, 0.2, 0.1, 0.5] # 对应T,S,D,W的线性系数
    unemployment_b_coeffs: [0.05, 0.01, 0.01, 0]
  exogenous_separation_mu: # 外生离职率函数参数
    eta_coeffs: [-1.0, -0.1, -0.2, -0.1, 0.05] # 截距项和对应T,S,D,W的系数
  convergence_criteria: # 收敛判据
    tolerance: 1.0e-6
    max_iterations: 1000

experiment_controller_settings:
  mode: "calibration" # "calibration" 或 "policy_analysis"
  calibration_target:
    unemployment_rate: 0.054 # 假设的现实目标失业率
  calibration_params: # 校准中可调整的参数及其范围
    mfg_simulator_settings.bellman_equation.effort_cost_kappa: [0.5, 2.5]
    mfg_simulator_settings.utility_functions.employment_omega_coeffs[0]: [0.05, 0.15]
  policy_scenarios:
    - name: "baseline"
      params_override: {}
    - name: "training_subsidy_policy"
      desc: "技能培训补贴使努力成本降低20%"
      params_override:
        mfg_simulator_settings:
          bellman_equation:
            kappa: 1.2 # 假设基准是1.5
    - name: "digital_inclusion_policy"
      desc: "数字基建改善使数字素养提升效用增加"
      params_override:
        mfg_simulator_settings:
          utility_functions:
            employment_omega_coeffs[2]: 0.15 # 假设基准是0.1
```
4. 模块化需求详解
4.1 模块1: PopulationGenerator (主体生成器)

核心职责: 根据配置生成符合特定边缘分布和相关性结构的虚拟“劳动力”和“企业”主体池。

输入:

配置文件依赖: io_paths, population_generator_settings

数据依赖: cleaned_data.csv (真实样本数据)

核心功能与实现要点:

加载: 从 io_paths.cleaned_data_csv 加载真实数据。

边缘分布拟合: 调用 distribution_inference.py 的核心逻辑，为劳动力端每个属性找到最佳边缘分布，并将参数结果保存到 io_paths.marginal_distributions_json。

企业主体生成: 根据 config.yaml 中为企业端设定的假设分布（如正态分布）及其参数，直接生成企业Agent池。

劳动力主体生成 (Copula):

读取 io_paths.marginal_distributions_json 获取边缘分布。

实现 copula_agent_generator.py 的核心流程：
a. 将真实劳动力数据转换为分位数空间。
b. 根据 copula_settings.candidate_families 拟合多个Copula模型。
c. 根据 copula_settings.selection_criterion (AIC/BIC) 选择最优Copula。
d. 使用最优Copula生成 n_labor_agents 个相关联的虚拟劳动力主体。

输出:

labor_agents.csv: 生成的劳动力主体池数据文件。

enterprise_agents.csv: 生成的企业主体池数据文件。

copula_report.md: Copula模型选择与验证报告。

4.2 模块2: MatchingEngine (匹配引擎)

核心职责: 模拟劳动力市场的一轮或多轮静态匹配过程，为匹配函数估计生成数据集。

输入:

配置文件依赖: matching_engine_settings

数据依赖: labor_agents.csv, enterprise_agents.csv

核心功能与实现要点:

加载Agent池: 读取劳动力和企业主体数据。

多情景循环: 遍历 market_tightness_scenarios 中定义的每个theta值。

根据theta值，从总池中抽样相应数量的劳动力和企业主体。

计算偏好: 根据 preference_function_coeffs 中定义的效用函数，为每个求职者计算其对所有企业的偏好排序，反之亦然。

运行匹配算法: 执行Gale-Shapley稳定匹配算法。

记录结果: 为每个参与本轮匹配的劳动力Agent，记录其所有属性、本轮的theta值以及最终的匹配结果（1=成功, 0=失败）。

数据汇总: 将所有情景下的匹配结果数据合并。

输出:

matching_data_for_logit.csv: 一个包含了多轮、多theta值下的综合匹配结果数据集。

4.3 模块3: MatchFunctionEstimator (匹配函数估计器)

核心职责: 使用匹配引擎生成的数据，估计出匹配概率函数 λ 的参数。

输入:

配置文件依赖: (无直接依赖，但模型形式参考研究计划.md)

数据依赖: matching_data_for_logit.csv

核心功能与实现要点:

加载数据: 读取匹配结果数据集。

构建回归模型: 根据研究计划中定义的Logit模型形式 λ = 1 / (1 + exp[-(δ_0 + δ'x + ...)])，构建模型。

执行Logit回归: 使用statsmodels或scikit-learn等库执行Logit回归。

参数提取: 提取并保存所有估计出的系数 δ。

输出:

match_function_params.json: 包含匹配函数 λ 所有估计系数 δ 的文件。

4.4 模块4: MFGSimulator (平均场博弈模拟器)

核心职责: 实现MFG核心迭代循环，求解给定参数下的市场均衡状态。

输入:

配置文件依赖: mfg_simulator_settings

数据依赖: match_function_params.json

核心功能与实现要点:

初始化:

状态空间离散化: 根据 discretization 配置，将每个状态变量（T,S,D,W）的连续空间划分为离散网格点。

初始化价值函数: 为就业和失业状态的价值函数 V_E 和 V_U 初始化（如全零矩阵）。

初始化人口分布: 在离散的状态空间上，初始化一个初始的失业人口分布 m_U。

核心迭代循环: 直到满足 convergence_criteria 中定义的收敛条件或达到最大迭代次数：
a. 计算宏观状态: 根据当前人口分布 m_U 计算总失业人数U和市场紧张度theta = V/U。
b. 求解贝尔曼方程 (值迭代):

对于状态空间中的每一个网格点 x，通过遍历所有可能的努力水平 a，找到使贝尔曼方程右侧最大化的最优努力 a*(x)，并记录下来。

使用这个最优策略 a* 更新整个价值函数 V_U 和 V_E。

重复此过程直到价值函数收敛。
c. 演化人口分布 (KFE):

根据上一步求出的最优努力策略 a*，应用柯尔莫哥洛夫前向方程 (KFE)，从当前的人口分布 m_U 和 m_E 计算出下一期的人口分布 m_U' 和 m_E'。
d. 检查收敛: 比较 m_U 与 m_U'（或对应的失业率u与u'），以及价值函数 V 与 V' 的变化。如果变化小于容忍度 tolerance，则跳出循环。

输出:

一个包含均衡结果的Python对象或字典，内容包括：

steady_state_unemployment_rate: 稳态失业率。

value_functions: 收敛后的价值函数。

optimal_policy_function: 最优努力 a*(x) 策略函数。

population_distribution: 均衡时的人口分布。

4.5 模块5: ExperimentController (实验控制器)

核心职责: 管理和自动化执行多次模拟实验，用于模型校准和政策分析。

输入:

配置文件依赖: experiment_controller_settings, mfg_simulator_settings

对象依赖: 需要能够调用 MFGSimulator 模块。

核心功能与实现要点:

读取模式: 根据 mode (calibration 或 policy_analysis) 决定执行流程。

校准模式:

定义一个目标函数，其输入为待校准参数（如kappa），输出为模拟出的失业率与 calibration_target 的差距。

使用优化算法（如网格搜索、贝叶斯优化）来寻找能最小化目标函数的参数值。

保存最优的校准参数。

政策分析模式:

加载校准好的基准参数。

遍历 policy_scenarios 中定义的每个情景。

对于每个情景，使用 params_override 中的设置覆盖基准参数。

调用 MFGSimulator 运行模拟。

收集并汇总所有政策情景下的均衡结果，进行对比分析。

输出:

calibration_results.json: 最优校准参数。

policy_analysis_report.md: 包含图表和关键指标对比的政策分析报告。

5. 附录：建议的数据结构

为便于模块间交互，建议定义统一的数据结构。

Agent数据结构 (可使用Pandas DataFrame行或自定义类)

Python

class JobSeekerAgent:
def init(self, agent_id, attributes):
self.id = agent_id
self.T = attributes['每周工作时长']
self.S = attributes['工作能力评分']
self.D = attributes['数字素养评分']
self.W = attributes['每月期望收入']
# ... 其他控制变量