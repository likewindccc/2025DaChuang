# CALIBRATION模块设计文档

## 文档信息

- 创建时间：2025/10/18 21:58
- 文档版本：1.0
- 文档状态：已确认
- 最后修改：2025/10/18 21:58

---

## 一、模块概述

### 1.1 模块定位

CALIBRATION（校准）模块是项目的核心模块之一，负责通过Simulated Method of Moments（SMM）方法校准MFG模型的结构参数，使模拟结果与真实数据或文献典型值相匹配。

### 1.2 核心功能

1. 目标矩（Target Moments）的定义与计算
2. SMM目标函数的实现
3. 两阶段校准流程的执行
4. 断点续跑与中间结果保存
5. 校准结果的分析与可视化

### 1.3 模块依赖

```
CALIBRATION模块
    ├── 依赖 → MFG模块（equilibrium_solver）
    ├── 依赖 → SIMULATOR模块（场景管理）
    ├── 依赖 → scipy.optimize（优化算法）
    └── 输出 → 校准后的参数配置
```

---

## 二、设计决策总结

### 2.1 用户确认的设计决策

根据需求确认文档，用户已明确以下决策：

1. **开发时机**：方案B（并行开发）
   - 先设计校准框架，等待敏感性分析完成后再运行

2. **数据策略**：方案A（文献典型值）
   - 使用中国劳动力市场研究的典型数据作为目标矩

3. **校准范围**：基础版本（5个核心参数）
   - 校准参数：rho, kappa, gamma_T, gamma_S, gamma_D, gamma_W

4. **校准方法**：两阶段校准
   - 阶段1：敏感性分析缩小参数范围
   - 阶段2：SMM精确校准

5. **目标矩数量**：3个核心矩
   - 失业率
   - 平均工资
   - 工资标准差
   - 权重策略：等权重

6. **计算资源**：可接受1-2天计算时间
   - 单线程运行
   - 必须有断点续跑功能
   - 预留CPU并行化接口

---

## 三、模块架构设计

### 3.1 文件结构

```
MODULES/CALIBRATION/
├── __init__.py                         # 模块接口
├── target_moments.py                   # 目标矩定义与计算
├── objective_function.py               # SMM目标函数
├── smm_calibrator.py                   # SMM校准器核心
├── optimization_utils.py               # 优化辅助函数（参数边界、初始值等）
└── calibration_results.py              # 结果分析与可视化

CONFIG/
├── calibration_config.yaml             # 校准配置
│   ├── 校准参数列表及边界
│   ├── 目标矩权重
│   ├── 优化算法参数
│   └── 断点续跑设置
└── target_moments.yaml                 # 目标矩数据（文献值）

TESTS/
├── test_calibration.py                 # 校准功能测试
└── test_target_moments.py              # 目标矩计算测试

OUTPUT/calibration/
├── calibration_history.csv             # 校准迭代历史
├── checkpoint_latest.pkl               # 最新断点文件
├── checkpoint_{timestamp}.pkl          # 历史断点文件
├── calibrated_parameters.yaml          # 校准后的参数
├── moment_comparison.csv               # 矩比较表（模拟 vs 目标）
├── convergence_diagnostics.txt         # 收敛诊断报告
└── diagnostic_plots/                   # 诊断图表
    ├── parameter_trace.png             # 参数迭代轨迹
    ├── objective_history.png           # 目标函数历史
    └── moment_fit.png                  # 矩拟合图
```

### 3.2 核心类设计

#### 3.2.1 TargetMoments（目标矩管理类）

```python
class TargetMoments:
    """
    目标矩管理类
    
    功能：
    - 加载目标矩数据（文献值）
    - 计算模拟数据的矩
    - 提供矩对比接口
    """
    
    def __init__(self, config_path: str)
    def load_target_moments(self) -> Dict
    def compute_simulated_moments(self, individuals: pd.DataFrame, eq_info: Dict) -> Dict
    def get_moment_vector(self, moments: Dict) -> np.ndarray
```

**设计要点**：
- 目标矩存储在 `target_moments.yaml` 中
- 模拟矩从MFG均衡结果中计算
- 返回标准化的矩向量用于SMM计算

---

#### 3.2.2 ObjectiveFunction（SMM目标函数类）

```python
class ObjectiveFunction:
    """
    SMM目标函数类
    
    功能：
    - 计算SMM距离
    - 管理权重矩阵
    - 记录每次评估结果
    """
    
    def __init__(self, target_moments: TargetMoments, weight_matrix: np.ndarray)
    def __call__(self, params: np.ndarray) -> float
    def get_moment_difference(self) -> np.ndarray
```

**SMM距离公式**：

```
J(θ) = [m_sim(θ) - m_target]' * W * [m_sim(θ) - m_target]

其中：
- θ: 待校准参数向量
- m_sim(θ): 模拟矩向量
- m_target: 目标矩向量
- W: 权重矩阵（基础版本使用单位矩阵，即等权重）
```

**设计要点**：
- 每次调用需要运行一次完整的MFG求解
- 计算结果需要记录到历史文件
- 支持自定义权重矩阵

---

#### 3.2.3 SMMCalibrator（SMM校准器类）

```python
class SMMCalibrator:
    """
    SMM校准器核心类
    
    功能：
    - 管理校准流程
    - 调用优化算法
    - 实现断点续跑
    - 保存中间结果
    """
    
    def __init__(self, config_path: str)
    def calibrate(self, method: str = 'Nelder-Mead') -> Dict
    def resume_from_checkpoint(self, checkpoint_path: str) -> Dict
    def save_checkpoint(self, iteration: int, params: np.ndarray, obj_value: float)
    def save_results(self, result: OptimizeResult)
```

**优化算法选择**：

基础版本使用 `scipy.optimize.minimize`，支持以下算法：

1. **Nelder-Mead**（默认）
   - 优势：不需要梯度，对初始值不敏感
   - 劣势：收敛较慢
   - 适用场景：5个参数的基础校准

2. **L-BFGS-B**（备选）
   - 优势：支持参数边界，收敛较快
   - 劣势：需要数值梯度（自动计算）
   - 适用场景：参数较多时

**断点续跑设计**：

```python
# 断点文件结构
checkpoint = {
    'timestamp': '2025/10/18 22:00',
    'iteration': 25,
    'current_params': np.array([...]),
    'current_obj_value': 0.123,
    'param_history': [...],
    'obj_history': [...],
    'best_params': np.array([...]),
    'best_obj_value': 0.100,
    'optimization_state': {...}  # 优化器内部状态
}
```

**设计要点**：
- 每10次迭代保存一次断点
- 保存最近3个断点文件，避免磁盘占用过大
- 支持手动中断后恢复

---

#### 3.2.4 OptimizationUtils（优化辅助工具类）

```python
class OptimizationUtils:
    """
    优化辅助工具类
    
    功能：
    - 管理参数边界
    - 生成初始值
    - 参数变换（对数/逻辑变换）
    """
    
    @staticmethod
    def get_parameter_bounds(config: Dict) -> List[Tuple]
    
    @staticmethod
    def get_initial_values(config: Dict, strategy: str = 'baseline') -> np.ndarray
    
    @staticmethod
    def transform_parameters(params: np.ndarray, transform_type: str) -> np.ndarray
```

**参数边界设计**（基于经济学理论和敏感性分析）：

| 参数 | 下界 | 上界 | 基准值 | 说明 |
|------|------|------|--------|------|
| rho | 0.60 | 0.95 | 0.75 | 贴现因子，不能太接近1（发散） |
| kappa | 0.30 | 3.00 | 1.00 | 努力成本系数 |
| gamma_T | 0.10 | 1.00 | 0.30 | T状态更新系数 |
| gamma_S | 0.10 | 1.50 | 0.45 | S状态更新系数 |
| gamma_D | 0.10 | 1.50 | 0.45 | D状态更新系数 |
| gamma_W | 0.05 | 0.50 | 0.15 | W状态更新系数 |

**初始值策略**：

1. **baseline策略**：使用当前配置文件中的参数
2. **literature策略**：使用文献中的典型值
3. **sensitivity策略**：使用敏感性分析的最优值
4. **random策略**：在边界内随机采样（用于鲁棒性测试）

---

## 四、配置文件设计

### 4.1 calibration_config.yaml

```yaml
# 校准配置文件

# 校准参数定义
parameters:
  - name: rho
    display_name: 贴现因子
    config_path: economics.rho  # 在mfg_config.yaml中的路径
    bounds: [0.60, 0.95]
    initial_value: 0.75
    transform: null  # 可选：'log', 'logit'
    
  - name: kappa
    display_name: 努力成本系数
    config_path: economics.kappa
    bounds: [0.30, 3.00]
    initial_value: 1.00
    transform: null
    
  - name: gamma_T
    display_name: T状态更新系数
    config_path: economics.state_update.gamma_T
    bounds: [0.10, 1.00]
    initial_value: 0.30
    transform: null
    
  - name: gamma_S
    display_name: S状态更新系数
    config_path: economics.state_update.gamma_S
    bounds: [0.10, 1.50]
    initial_value: 0.45
    transform: null
    
  - name: gamma_D
    display_name: D状态更新系数
    config_path: economics.state_update.gamma_D
    bounds: [0.10, 1.50]
    initial_value: 0.45
    transform: null
    
  - name: gamma_W
    display_name: W状态更新系数
    config_path: economics.state_update.gamma_W
    bounds: [0.05, 0.50]
    initial_value: 0.15
    transform: null

# 目标矩定义
target_moments:
  - name: unemployment_rate
    display_name: 失业率
    weight: 1.0
    
  - name: mean_wage
    display_name: 平均工资
    weight: 1.0
    
  - name: std_wage
    display_name: 工资标准差
    weight: 1.0

# 优化算法设置
optimization:
  method: Nelder-Mead  # 可选：'L-BFGS-B', 'Powell', 'TNC'
  options:
    maxiter: 200  # 最大迭代次数
    maxfev: 1000  # 最大函数评估次数
    xatol: 1.0e-4  # 参数收敛阈值
    fatol: 1.0e-4  # 目标函数收敛阈值
    adaptive: true  # Nelder-Mead自适应参数

# 断点续跑设置
checkpoint:
  enabled: true
  save_frequency: 10  # 每N次迭代保存一次
  keep_last_n: 3  # 保留最近N个断点文件
  auto_resume: true  # 启动时自动检测并恢复

# MFG求解设置
mfg_solver:
  config_path: CONFIG/mfg_config.yaml
  max_iterations: 100  # MFG求解的最大迭代次数
  convergence_check: true  # 是否检查收敛性

# 输出设置
output:
  save_history: true
  save_plots: true
  verbose: 2  # 0: 静默, 1: 基本, 2: 详细
  log_file: OUTPUT/calibration/calibration.log
```

### 4.2 target_moments.yaml

```yaml
# 目标矩数据（文献典型值）

# 数据来源说明
source:
  description: 中国劳动力市场典型值
  references:
    - 中国统计年鉴2020-2024
    - 中国劳动力动态调查（CLDS）
    - 相关学术文献
  notes: |
    失业率参考城镇调查失业率（2020-2024年平均）
    工资数据参考城镇单位就业人员平均工资（月度）

# 目标矩定义
moments:
  unemployment_rate:
    value: 0.048  # 4.8%（城镇调查失业率典型值）
    unit: 比例
    source: 国家统计局
    confidence_interval: [0.042, 0.055]  # 95%置信区间
    
  mean_wage:
    value: 4500.0  # 4500元/月
    unit: 元
    source: 统计年鉴（调整为月度）
    confidence_interval: [4000.0, 5000.0]
    
  std_wage:
    value: 1500.0  # 1500元
    unit: 元
    source: CLDS数据估算
    confidence_interval: [1200.0, 1800.0]

# 可选的分组矩（暂不使用）
optional_moments:
  unemployment_rate_by_education:
    low: 0.065
    medium: 0.045
    high: 0.030
    
  unemployment_rate_by_age:
    age_20_30: 0.082
    age_30_40: 0.040
    age_40_50: 0.035
    age_50_60: 0.045
```

---

## 五、工作流程设计

### 5.1 两阶段校准流程

#### 阶段1：敏感性分析（当前进行中）

**目标**：缩小参数搜索空间

**步骤**：
1. 测试rho在[0.70, 0.85]范围内的影响
2. 测试kappa在[0.5, 2.0]范围内的影响
3. 测试gamma系数的缩放倍数[0.5, 2.0]
4. 测试damping_factor在[0.1, 0.7]范围内的影响

**输出**：
- 每个参数的敏感性排名
- 建议的参数搜索范围
- 识别的参数识别问题

**预计时间**：2-3小时（已启动）

---

#### 阶段2：SMM精确校准

**输入**：
- 阶段1的敏感性分析结果
- 调整后的参数边界
- 目标矩数据

**流程**：

```
开始
  │
  ├─ 1. 加载配置和目标矩
  │
  ├─ 2. 检查是否有断点文件
  │   ├─ 是 → 恢复状态
  │   └─ 否 → 初始化参数
  │
  ├─ 3. 开始优化迭代
  │   │
  │   └─ 每次迭代：
  │       ├─ a. 更新MFG配置文件
  │       ├─ b. 运行MFG求解
  │       ├─ c. 计算模拟矩
  │       ├─ d. 计算SMM距离
  │       ├─ e. 记录结果
  │       └─ f. 每10次迭代保存断点
  │
  ├─ 4. 优化完成
  │   ├─ 收敛 → 保存最优参数
  │   └─ 未收敛 → 保存当前最优 + 警告
  │
  ├─ 5. 生成诊断报告
  │   ├─ 参数迭代轨迹图
  │   ├─ 目标函数历史图
  │   ├─ 矩拟合对比图
  │   └─ 收敛诊断文本
  │
  └─ 6. 更新mfg_config.yaml
      └─ 使用校准后的最优参数
```

**预计时间**：
- 单次MFG求解：5-8分钟
- 预计迭代次数：50-150次
- 总时间：4-20小时

---

### 5.2 断点续跑机制

**触发条件**：
- 手动中断（Ctrl+C）
- 系统崩溃
- 达到时间限制

**恢复流程**：

```python
# 伪代码
if checkpoint_exists and auto_resume:
    checkpoint = load_checkpoint('checkpoint_latest.pkl')
    params = checkpoint['current_params']
    iteration = checkpoint['iteration']
    history = checkpoint['history']
    
    print(f"从第 {iteration} 次迭代恢复...")
    
    # 恢复优化器状态
    optimizer.set_state(checkpoint['optimization_state'])
    
    # 继续优化
    continue_optimization(params, iteration)
else:
    # 从头开始
    start_fresh_calibration()
```

**断点文件管理**：
- 自动保存：每10次迭代
- 文件命名：`checkpoint_{timestamp}.pkl`
- 符号链接：`checkpoint_latest.pkl` 指向最新断点
- 清理策略：只保留最近3个断点文件

---

## 六、测试策略

### 6.1 单元测试

#### test_target_moments.py

测试内容：
1. 目标矩加载
2. 模拟矩计算
3. 矩向量生成
4. 边界情况处理

#### test_objective_function.py

测试内容：
1. SMM距离计算
2. 权重矩阵应用
3. 梯度数值验证（如使用）

#### test_optimization_utils.py

测试内容：
1. 参数边界生成
2. 初始值生成
3. 参数变换

---

### 6.2 集成测试

#### test_calibration.py

测试场景：
1. **快速测试**（5次迭代）
   - 验证流程完整性
   - 验证断点保存/恢复
   - 预计时间：30-40分钟

2. **小规模测试**（20次迭代）
   - 验证收敛趋势
   - 验证结果输出
   - 预计时间：2-3小时

3. **完整测试**（运行至收敛或200次迭代）
   - 实际校准运行
   - 预计时间：4-20小时

---

## 七、风险识别与缓解

### 7.1 已识别风险

#### 风险1：参数识别问题

**描述**：某些参数组合可能产生相似的矩，导致无法唯一确定参数

**可能性**：中等

**影响**：参数估计不稳定，对初始值敏感

**缓解措施**：
1. 使用敏感性分析结果识别高相关参数
2. 固定部分参数，减少自由度
3. 增加目标矩数量（如果数据允许）
4. 尝试多个初始值，检查收敛一致性

---

#### 风险2：目标矩不匹配

**描述**：文献典型值与模型结构不完全匹配

**可能性**：高

**影响**：校准后的参数可能不合理，模型行为异常

**缓解措施**：
1. 使用敏感性分析验证参数合理性
2. 设置严格的参数边界
3. 进行事后诊断（校准后运行模型验证）
4. 保留校准历史，分析参数演化轨迹

---

#### 风险3：计算时间过长

**描述**：200次迭代可能需要20+小时

**可能性**：中等

**影响**：影响开发进度

**缓解措施**：
1. 使用断点续跑机制
2. 降低MFG求解精度（减少max_iter）
3. 如果必要，实现多进程并行评估
4. 使用更快的优化算法（如Powell）

---

#### 风险4：敏感性分析发现结构问题

**描述**：模型本身存在设计缺陷

**可能性**：中低

**影响**：校准无意义，需要重新设计模型

**缓解措施**：
1. 等待敏感性分析完成，先诊断问题
2. 如发现严重问题，暂停校准，修复模型
3. 记录所有尝试，为未来改进提供依据

---

## 八、开发计划

### 8.1 阶段1：框架搭建（预计2-3小时）

**任务清单**：

1. 创建模块文件结构
   - 创建 `MODULES/CALIBRATION/` 目录
   - 创建 `__init__.py`, `target_moments.py`, `objective_function.py`, `smm_calibrator.py`
   - 创建配置文件和测试文件

2. 实现 `target_moments.py`
   - `TargetMoments` 类
   - 目标矩加载函数
   - 模拟矩计算函数

3. 实现 `objective_function.py`
   - `ObjectiveFunction` 类
   - SMM距离计算

4. 编写 `calibration_config.yaml` 和 `target_moments.yaml`

---

### 8.2 阶段2：核心开发（预计3-4小时）

**任务清单**：

1. 实现 `smm_calibrator.py`
   - `SMMCalibrator` 类
   - 主校准流程
   - 断点续跑机制

2. 实现 `optimization_utils.py`
   - 参数边界管理
   - 初始值生成
   - 参数变换

3. 集成 `scipy.optimize`
   - 配置优化器
   - 实现回调函数
   - 结果保存

---

### 8.3 阶段3：测试与调试（预计1-2小时）

**任务清单**：

1. 编写单元测试
   - `test_target_moments.py`
   - 测试矩计算逻辑

2. 编写集成测试
   - `test_calibration.py`
   - 快速测试（5次迭代）

3. 调试与优化
   - 修复发现的bug
   - 优化性能瓶颈

---

### 8.4 阶段4：运行与分析（预计1-2天）

**前置条件**：
- 敏感性分析完成
- 根据敏感性分析结果调整参数边界

**任务清单**：

1. 运行完整校准
   - 使用调整后的参数范围
   - 监控收敛过程

2. 结果分析
   - 生成诊断报告
   - 验证参数合理性
   - 对比校准前后的模型表现

3. 文档更新
   - 更新项目文档
   - 记录校准结果
   - 撰写分析报告

---

## 九、成功标准

### 9.1 功能性标准

1. 校准器能够成功运行并收敛
2. 断点续跑功能正常工作
3. 所有输出文件正确生成
4. 测试全部通过

### 9.2 质量标准

1. **拟合质量**
   - SMM距离显著降低（降低50%以上）
   - 主要矩的相对误差 < 10%
   - 失业率：目标4.8%，误差±0.5个百分点
   - 平均工资：目标4500元，误差±500元

2. **参数合理性**
   - 所有参数在边界内
   - 与敏感性分析结果一致
   - 经济学解释合理

3. **收敛性**
   - 优化器报告收敛
   - 参数在最后20次迭代中稳定
   - 目标函数单调下降（允许小幅波动）

### 9.3 性能标准

1. 单次MFG求解时间 < 10分钟
2. 断点保存时间 < 5秒
3. 完整校准时间 < 24小时

---

## 十、后续扩展方向

### 10.1 短期扩展（v1.1）

1. **多初始值鲁棒性测试**
   - 从不同初始值开始校准
   - 验证结果一致性

2. **敏感性分析集成**
   - 自动从敏感性分析结果中读取参数范围
   - 生成初始值建议

3. **可视化增强**
   - 实时监控界面
   - 交互式参数轨迹图

### 10.2 中期扩展（v1.2）

1. **并行化支持**
   - 多进程并行评估不同参数组合
   - 预期加速比：4-6倍

2. **更多目标矩**
   - 分组失业率
   - 工资分位数
   - 求职时长

3. **权重矩阵优化**
   - 基于方差的最优权重
   - 自适应权重调整

### 10.3 长期扩展（v2.0）

1. **贝叶斯校准**
   - 参数不确定性量化
   - 后验分布估计

2. **GPU加速**
   - 如果计算时间成为瓶颈
   - 需要大量代码重构

3. **自动模型诊断**
   - 识别模型结构问题
   - 提出改进建议

---

## 十一、参考文献

### 学术文献

1. Lee, D., & Wolpin, K. I. (2006). Intersectoral labor mobility and the growth of the service sector. Econometrica, 74(1), 1-46.

2. Gourieroux, C., Monfort, A., & Renault, E. (1993). Indirect inference. Journal of applied econometrics, 8(S1), S85-S118.

3. Smith, A. A. (1993). Estimating nonlinear time-series models using simulated vector autoregressions. Journal of Applied Econometrics, 8(S1), S63-S84.

### 数据来源

1. 国家统计局：中国统计年鉴（2020-2024）
2. 中国社会科学院：中国劳动力动态调查（CLDS）
3. 人力资源和社会保障部：劳动力市场分析报告

---

## 附录A：术语表

| 术语 | 英文 | 说明 |
|------|------|------|
| SMM | Simulated Method of Moments | 模拟矩方法，用于估计参数 |
| 目标矩 | Target Moments | 真实数据或文献中的统计矩 |
| 模拟矩 | Simulated Moments | 模型模拟产生的统计矩 |
| 断点续跑 | Checkpointing | 保存中间状态，允许从中断处恢复 |
| 参数识别 | Parameter Identification | 参数能否被唯一确定 |
| 权重矩阵 | Weight Matrix | SMM中用于加权不同矩的矩阵 |

---

## 附录B：FAQ

### Q1：为什么选择SMM而不是Maximum Likelihood？

**A**：MFG模型的似然函数难以直接计算，而SMM只需要模拟数据的矩，实现更简单。

### Q2：如果校准后参数不合理怎么办？

**A**：
1. 检查目标矩数据是否正确
2. 尝试不同的初始值
3. 调整参数边界
4. 增加目标矩数量
5. 考虑模型结构是否需要修改

### Q3：校准需要多长时间？

**A**：取决于迭代次数和收敛速度，预计4-20小时。可以使用断点续跑分多次运行。

### Q4：可以使用GPU加速吗？

**A**：当前版本不支持。MFG模块使用Numba JIT优化，CPU性能已经不错。如果后期需要，可以考虑重构为Numba CUDA版本。

---

**文档结束**

