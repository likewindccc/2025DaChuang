# MFG值函数修正方案

## 问题诊断

### 核心问题
1. **就业价值函数V_E数值爆炸**：ρ*(1-μ) ≈ 0.9，值迭代不稳定
2. **索引映射错误**：失业者使用就业者的V_E时索引不匹配
3. **最优努力全为0**：由于V_E异常导致优化失败

## 解决方案

### 方案1：使用相对价值函数（推荐）

**核心思想**：不直接存储V_U和V_E，而是存储价值差 Δ = V_E - V_U

**优势**：
- 数值更稳定（差值有界）
- 避免绝对值爆炸
- 符合经济学直觉（失业vs就业的相对价值）

**修改**：
```python
# 贝尔曼方程变为：
Δ_t = ω - b + (ρ*μ - ρ*λ) * Δ_{t-1}

# 失业者决策：
max_a { b - 0.5*κ*a² + ρ*λ*Δ }
```

### 方案2：降低贴现因子

**简单粗暴的方法**：
```yaml
# CONFIG/mfg_config.yaml
economics:
  rho: 0.90  # 从0.95降到0.90
```

**优势**：
- 实现简单，不需要改代码
- 降低累积效应

**劣势**：
- 治标不治本
- 改变了模型的经济含义

### 方案3：添加价值函数上下界

**在值迭代中限制范围**：
```python
# 在value_iteration_numba中
V_U = np.clip(V_U, -1e6, 1e6)
V_E = np.clip(V_E, -1e6, 1e6)
```

**优势**：
- 防止数值溢出
- 保持迭代稳定

**劣势**：
- 可能掩盖真实问题
- 边界值选择需要调整

### 方案4：修正索引逻辑（必须）

**问题**：失业者和就业者的V数组长度不同

**解决**：
```python
# 方法A：所有个体都维护V_U和V_E（推荐）
V_U = np.zeros(N)  # 所有N个个体
V_E = np.zeros(N)  # 所有N个个体

# 失业者i：使用V_U[i]和V_E[i]
# 就业者j：使用V_U[j]和V_E[j]

# 方法B：使用插值（复杂）
# 失业者i匹配成功后，插值估计V_E
```

## 推荐实施顺序

1. **立即修改**：方案4（修正索引）+ 方案3（添加上下界）
2. **进一步优化**：方案2（降低ρ到0.90）
3. **长期方案**：方案1（相对价值函数，需要重构）

## 预期效果

修改后应该看到：
- V_E在合理范围（10^4到10^5量级）
- V_U在合理范围（10^4量级）
- a_optimal在0到1之间有分布
- 能够收敛到稳态

